import {
  extractVulnerabilityIds,
  resolveVulnerabilityIds,
  getVulnerabilityTitle,
  getVulnerabilityUrl,
  resolveVulnerabilityTitle,
  resolveVulnerabilityUrl,
} from './extractVulnerabilityInfo';
import { Vulnerability } from '../../shared/types';

describe('extractVulnerabilityInfo', () => {
  const createMockVulnerability = (overrides: Partial<Vulnerability> = {}): Vulnerability => ({
    id: 1,
    name: 'test-package',
    severity: 'high',
    title: 'Default Title',
    url: 'https://default.url',
    range: '*',
    via: [
      {
        source: 123456,
        name: 'test-package',
        dependency: 'test-package',
        title: 'Test vulnerability title',
        url: 'https://npmjs.com/advisories/123456',
        severity: 'high',
        range: '*',
      },
    ],
    effects: [],
    fixAvailable: false,
    ...overrides,
  });

  describe('extractVulnerabilityIds', () => {
    it('should extract source IDs from via array', () => {
      const vuln = createMockVulnerability({
        via: [
          {
            source: 111,
            name: 'pkg',
            dependency: 'pkg',
            title: 'Issue 1',
            url: 'https://example.com/111',
            severity: 'high',
            range: '*',
          },
          {
            source: 222,
            name: 'pkg',
            dependency: 'pkg',
            title: 'Issue 2',
            url: 'https://example.com/222',
            severity: 'high',
            range: '*',
          },
        ],
      });

      const ids = extractVulnerabilityIds(vuln);
      expect(ids).toEqual([111, 222]);
    });

    it('should ignore string entries in via array', () => {
      const vuln = createMockVulnerability({
        via: ['some-package', 'another-package'],
      });

      const ids = extractVulnerabilityIds(vuln);
      expect(ids).toEqual([]);
    });

    it('should handle mixed via entries', () => {
      const vuln = createMockVulnerability({
        via: [
          'some-package',
          {
            source: 333,
            name: 'pkg',
            dependency: 'pkg',
            title: 'Issue',
            url: 'https://example.com/333',
            severity: 'high',
            range: '*',
          },
        ],
      });

      const ids = extractVulnerabilityIds(vuln);
      expect(ids).toEqual([333]);
    });

    it('should return empty array for empty via', () => {
      const vuln = createMockVulnerability({ via: [] });
      const ids = extractVulnerabilityIds(vuln);
      expect(ids).toEqual([]);
    });
  });

  describe('getVulnerabilityTitle', () => {
    it('should return title from first via object', () => {
      const vuln = createMockVulnerability();
      const title = getVulnerabilityTitle(vuln);
      expect(title).toBe('Test vulnerability title');
    });

    it('should fall back to vulnerability title', () => {
      const vuln = createMockVulnerability({
        title: 'Fallback Title',
        via: ['string-only'],
      });
      const title = getVulnerabilityTitle(vuln);
      expect(title).toBe('Fallback Title');
    });

    it('should return Unknown for no title', () => {
      const vuln = createMockVulnerability({
        title: '',
        via: [],
      });
      const title = getVulnerabilityTitle(vuln);
      expect(title).toBe('Unknown vulnerability');
    });
  });

  describe('getVulnerabilityUrl', () => {
    it('should return URL from first via object', () => {
      const vuln = createMockVulnerability();
      const url = getVulnerabilityUrl(vuln);
      expect(url).toBe('https://npmjs.com/advisories/123456');
    });

    it('should fall back to vulnerability url', () => {
      const vuln = createMockVulnerability({
        url: 'https://fallback.url',
        via: ['string-only'],
      });
      const url = getVulnerabilityUrl(vuln);
      expect(url).toBe('https://fallback.url');
    });

    it('should return empty string for no url', () => {
      const vuln = createMockVulnerability({
        url: '',
        via: [],
      });
      const url = getVulnerabilityUrl(vuln);
      expect(url).toBe('');
    });
  });

  describe('resolveVulnerabilityIds', () => {
    it('should return source IDs for direct vulnerabilities', () => {
      const vuln = createMockVulnerability({
        name: 'minimatch',
        via: [
          {
            source: 111,
            name: 'minimatch',
            dependency: 'minimatch',
            title: 'ReDoS',
            url: 'https://example.com/111',
            severity: 'high',
            range: '*',
          },
        ],
      });

      const allVulns = { minimatch: vuln };
      const ids = resolveVulnerabilityIds(vuln, allVulns);
      expect(ids).toEqual([111]);
    });

    it('should resolve transitive string references to source IDs', () => {
      const rootVuln = createMockVulnerability({
        name: 'minimatch',
        via: [
          {
            source: 111,
            name: 'minimatch',
            dependency: 'minimatch',
            title: 'ReDoS',
            url: 'https://example.com/111',
            severity: 'high',
            range: '*',
          },
        ],
      });

      const transitiveVuln = createMockVulnerability({
        name: '@eslint/config-array',
        severity: 'high',
        via: ['minimatch'],
      });

      const allVulns = {
        minimatch: rootVuln,
        '@eslint/config-array': transitiveVuln,
      };

      const ids = resolveVulnerabilityIds(transitiveVuln, allVulns);
      expect(ids).toEqual([111]);
    });

    it('should resolve deeply nested transitive chains', () => {
      const rootVuln = createMockVulnerability({
        name: 'minimatch',
        via: [
          {
            source: 111,
            name: 'minimatch',
            dependency: 'minimatch',
            title: 'ReDoS',
            url: 'https://example.com/111',
            severity: 'high',
            range: '*',
          },
        ],
      });

      const midVuln = createMockVulnerability({
        name: 'glob',
        severity: 'high',
        via: ['minimatch'],
      });

      const topVuln = createMockVulnerability({
        name: 'rimraf',
        severity: 'high',
        via: ['glob'],
      });

      const allVulns = {
        minimatch: rootVuln,
        glob: midVuln,
        rimraf: topVuln,
      };

      const ids = resolveVulnerabilityIds(topVuln, allVulns);
      expect(ids).toEqual([111]);
    });

    it('should handle circular references without infinite loop', () => {
      const vulnA = createMockVulnerability({
        name: 'pkg-a',
        severity: 'high',
        via: ['pkg-b'],
      });

      const vulnB = createMockVulnerability({
        name: 'pkg-b',
        severity: 'high',
        via: ['pkg-a'],
      });

      const allVulns = { 'pkg-a': vulnA, 'pkg-b': vulnB };
      const ids = resolveVulnerabilityIds(vulnA, allVulns);
      expect(ids).toEqual([]);
    });

    it('should deduplicate IDs from multiple paths', () => {
      const rootVuln = createMockVulnerability({
        name: 'minimatch',
        via: [
          {
            source: 111,
            name: 'minimatch',
            dependency: 'minimatch',
            title: 'ReDoS',
            url: 'https://example.com/111',
            severity: 'high',
            range: '*',
          },
        ],
      });

      const transitiveVuln = createMockVulnerability({
        name: 'parent-pkg',
        severity: 'high',
        via: ['minimatch', 'minimatch'],
      });

      const allVulns = {
        minimatch: rootVuln,
        'parent-pkg': transitiveVuln,
      };

      const ids = resolveVulnerabilityIds(transitiveVuln, allVulns);
      expect(ids).toEqual([111]);
    });

    it('should collect IDs from multiple different root vulnerabilities', () => {
      const rootA = createMockVulnerability({
        name: 'vuln-a',
        via: [
          {
            source: 111,
            name: 'vuln-a',
            dependency: 'vuln-a',
            title: 'Issue A',
            url: 'https://example.com/111',
            severity: 'high',
            range: '*',
          },
        ],
      });

      const rootB = createMockVulnerability({
        name: 'vuln-b',
        via: [
          {
            source: 222,
            name: 'vuln-b',
            dependency: 'vuln-b',
            title: 'Issue B',
            url: 'https://example.com/222',
            severity: 'high',
            range: '*',
          },
        ],
      });

      const transitiveVuln = createMockVulnerability({
        name: 'parent-pkg',
        severity: 'high',
        via: ['vuln-a', 'vuln-b'],
      });

      const allVulns = {
        'vuln-a': rootA,
        'vuln-b': rootB,
        'parent-pkg': transitiveVuln,
      };

      const ids = resolveVulnerabilityIds(transitiveVuln, allVulns);
      expect(ids).toEqual([111, 222]);
    });

    it('should handle string reference to non-existent package gracefully', () => {
      const vuln = createMockVulnerability({
        name: 'pkg',
        severity: 'high',
        via: ['non-existent-package'],
      });

      const allVulns = { pkg: vuln };
      const ids = resolveVulnerabilityIds(vuln, allVulns);
      expect(ids).toEqual([]);
    });
  });

  describe('resolveVulnerabilityTitle', () => {
    it('should return title from direct via object', () => {
      const vuln = createMockVulnerability();
      const allVulns = { 'test-package': vuln };
      const title = resolveVulnerabilityTitle(vuln, allVulns);
      expect(title).toBe('Test vulnerability title');
    });

    it('should resolve title from transitive string reference', () => {
      const rootVuln = createMockVulnerability({
        name: 'minimatch',
        via: [
          {
            source: 111,
            name: 'minimatch',
            dependency: 'minimatch',
            title: 'ReDoS vulnerability in minimatch',
            url: 'https://example.com/111',
            severity: 'high',
            range: '*',
          },
        ],
      });

      const transitiveVuln = createMockVulnerability({
        name: '@eslint/config-array',
        title: '',
        url: '',
        severity: 'high',
        via: ['minimatch'],
      });

      const allVulns = {
        minimatch: rootVuln,
        '@eslint/config-array': transitiveVuln,
      };

      const title = resolveVulnerabilityTitle(transitiveVuln, allVulns);
      expect(title).toBe('ReDoS vulnerability in minimatch');
    });

    it('should resolve title through deeply nested chain', () => {
      const rootVuln = createMockVulnerability({
        name: 'minimatch',
        via: [
          {
            source: 111,
            name: 'minimatch',
            dependency: 'minimatch',
            title: 'Deep root title',
            url: 'https://example.com/111',
            severity: 'high',
            range: '*',
          },
        ],
      });

      const midVuln = createMockVulnerability({
        name: 'glob',
        title: '',
        url: '',
        severity: 'high',
        via: ['minimatch'],
      });

      const topVuln = createMockVulnerability({
        name: 'rimraf',
        title: '',
        url: '',
        severity: 'high',
        via: ['glob'],
      });

      const allVulns = { minimatch: rootVuln, glob: midVuln, rimraf: topVuln };
      const title = resolveVulnerabilityTitle(topVuln, allVulns);
      expect(title).toBe('Deep root title');
    });

    it('should return Unknown vulnerability for unresolvable reference', () => {
      const vuln = createMockVulnerability({
        name: 'pkg',
        title: '',
        severity: 'high',
        via: ['non-existent'],
      });

      const allVulns = { pkg: vuln };
      const title = resolveVulnerabilityTitle(vuln, allVulns);
      expect(title).toBe('Unknown vulnerability');
    });

    it('should handle circular references without infinite loop', () => {
      const vulnA = createMockVulnerability({
        name: 'pkg-a',
        title: '',
        severity: 'high',
        via: ['pkg-b'],
      });

      const vulnB = createMockVulnerability({
        name: 'pkg-b',
        title: '',
        severity: 'high',
        via: ['pkg-a'],
      });

      const allVulns = { 'pkg-a': vulnA, 'pkg-b': vulnB };
      const title = resolveVulnerabilityTitle(vulnA, allVulns);
      expect(title).toBe('Unknown vulnerability');
    });
  });

  describe('resolveVulnerabilityUrl', () => {
    it('should return URL from direct via object', () => {
      const vuln = createMockVulnerability();
      const allVulns = { 'test-package': vuln };
      const url = resolveVulnerabilityUrl(vuln, allVulns);
      expect(url).toBe('https://npmjs.com/advisories/123456');
    });

    it('should resolve URL from transitive string reference', () => {
      const rootVuln = createMockVulnerability({
        name: 'minimatch',
        via: [
          {
            source: 111,
            name: 'minimatch',
            dependency: 'minimatch',
            title: 'ReDoS',
            url: 'https://github.com/advisories/GHSA-1234',
            severity: 'high',
            range: '*',
          },
        ],
      });

      const transitiveVuln = createMockVulnerability({
        name: '@eslint/config-array',
        title: '',
        url: '',
        severity: 'high',
        via: ['minimatch'],
      });

      const allVulns = {
        minimatch: rootVuln,
        '@eslint/config-array': transitiveVuln,
      };

      const url = resolveVulnerabilityUrl(transitiveVuln, allVulns);
      expect(url).toBe('https://github.com/advisories/GHSA-1234');
    });

    it('should resolve URL through deeply nested chain', () => {
      const rootVuln = createMockVulnerability({
        name: 'minimatch',
        via: [
          {
            source: 111,
            name: 'minimatch',
            dependency: 'minimatch',
            title: 'ReDoS',
            url: 'https://deep-root-url.com',
            severity: 'high',
            range: '*',
          },
        ],
      });

      const midVuln = createMockVulnerability({
        name: 'glob',
        title: '',
        url: '',
        severity: 'high',
        via: ['minimatch'],
      });

      const topVuln = createMockVulnerability({
        name: 'rimraf',
        title: '',
        url: '',
        severity: 'high',
        via: ['glob'],
      });

      const allVulns = { minimatch: rootVuln, glob: midVuln, rimraf: topVuln };
      const url = resolveVulnerabilityUrl(topVuln, allVulns);
      expect(url).toBe('https://deep-root-url.com');
    });

    it('should return empty string for unresolvable reference', () => {
      const vuln = createMockVulnerability({
        name: 'pkg',
        url: '',
        severity: 'high',
        via: ['non-existent'],
      });

      const allVulns = { pkg: vuln };
      const url = resolveVulnerabilityUrl(vuln, allVulns);
      expect(url).toBe('');
    });

    it('should handle circular references without infinite loop', () => {
      const vulnA = createMockVulnerability({
        name: 'pkg-a',
        url: '',
        severity: 'high',
        via: ['pkg-b'],
      });

      const vulnB = createMockVulnerability({
        name: 'pkg-b',
        url: '',
        severity: 'high',
        via: ['pkg-a'],
      });

      const allVulns = { 'pkg-a': vulnA, 'pkg-b': vulnB };
      const url = resolveVulnerabilityUrl(vulnA, allVulns);
      expect(url).toBe('');
    });
  });
});
