import { Vulnerability, VulnerabilityVia } from '../../shared/types';

/**
 * Extract all vulnerability IDs from a vulnerability entry
 * These are the source IDs from the 'via' array
 */
export function extractVulnerabilityIds(vulnerability: Vulnerability): number[] {
  const ids: number[] = [];

  for (const via of vulnerability.via) {
    if (typeof via === 'object' && 'source' in via) {
      ids.push((via as VulnerabilityVia).source);
    }
  }

  return ids;
}

/**
 * Resolve all vulnerability source IDs for a vulnerability entry,
 * following string references in the 'via' array to find root vulnerabilities.
 *
 * For direct vulnerabilities (via contains VulnerabilityVia objects), returns their source IDs.
 * For transitive vulnerabilities (via contains package name strings), follows the chain
 * through the full vulnerabilities map to find the underlying source IDs.
 */
export function resolveVulnerabilityIds(
  vulnerability: Vulnerability,
  allVulnerabilities: Record<string, Vulnerability>
): number[] {
  const ids = new Set<number>();
  const visited = new Set<string>();

  function resolve(vuln: Vulnerability): void {
    for (const via of vuln.via) {
      if (typeof via === 'object' && 'source' in via) {
        ids.add((via as VulnerabilityVia).source);
      } else if (typeof via === 'string') {
        if (!visited.has(via)) {
          visited.add(via);
          const referenced = allVulnerabilities[via];
          if (referenced) {
            resolve(referenced);
          }
        }
      }
    }
  }

  resolve(vulnerability);
  return Array.from(ids);
}

/**
 * Get the title of the first vulnerability via entry
 */
export function getVulnerabilityTitle(vulnerability: Vulnerability): string {
  for (const via of vulnerability.via) {
    if (typeof via === 'object' && 'title' in via) {
      return (via as VulnerabilityVia).title;
    }
  }
  return vulnerability.title || 'Unknown vulnerability';
}

/**
 * Get the URL of the first vulnerability via entry
 */
export function getVulnerabilityUrl(vulnerability: Vulnerability): string {
  for (const via of vulnerability.via) {
    if (typeof via === 'object' && 'url' in via) {
      return (via as VulnerabilityVia).url;
    }
  }
  return vulnerability.url || '';
}

/**
 * Resolve the title for a vulnerability, following string references in the 'via' array
 * to find the root vulnerability's title when the current entry is transitive.
 */
export function resolveVulnerabilityTitle(
  vulnerability: Vulnerability,
  allVulnerabilities: Record<string, Vulnerability>
): string {
  // Try direct via objects first
  const directTitle = getVulnerabilityTitle(vulnerability);
  if (directTitle !== 'Unknown vulnerability') {
    return directTitle;
  }

  // Follow string references
  const visited = new Set<string>();
  function resolve(vuln: Vulnerability): string | null {
    for (const via of vuln.via) {
      if (typeof via === 'object' && 'title' in via) {
        return (via as VulnerabilityVia).title;
      } else if (typeof via === 'string' && !visited.has(via)) {
        visited.add(via);
        const referenced = allVulnerabilities[via];
        if (referenced) {
          const result = resolve(referenced);
          if (result) return result;
        }
      }
    }
    return null;
  }

  return resolve(vulnerability) || vulnerability.title || 'Unknown vulnerability';
}

/**
 * Resolve the URL for a vulnerability, following string references in the 'via' array
 * to find the root vulnerability's URL when the current entry is transitive.
 */
export function resolveVulnerabilityUrl(
  vulnerability: Vulnerability,
  allVulnerabilities: Record<string, Vulnerability>
): string {
  // Try direct via objects first
  const directUrl = getVulnerabilityUrl(vulnerability);
  if (directUrl !== '') {
    return directUrl;
  }

  // Follow string references
  const visited = new Set<string>();
  function resolve(vuln: Vulnerability): string | null {
    for (const via of vuln.via) {
      if (typeof via === 'object' && 'url' in via) {
        return (via as VulnerabilityVia).url;
      } else if (typeof via === 'string' && !visited.has(via)) {
        visited.add(via);
        const referenced = allVulnerabilities[via];
        if (referenced) {
          const result = resolve(referenced);
          if (result) return result;
        }
      }
    }
    return null;
  }

  return resolve(vulnerability) || vulnerability.url || '';
}
